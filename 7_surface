# サーフェス

デバイスを確保できたので、GPUに命令を送る準備が進んできました。
次に考えるのは、ディスプレイへの表示になります。

ディスプレイへの表示はOSが行います。
具体的には、「画面のどの場所にウィンドウを表示するのか？」、「全画面なのか？」、
「ウィンドウが後ろに隠れているので、今は画面に書き込まなくても良いんじゃない？」
等を気にしながら、描画結果を画面の一部に描き込む処理を管理します。

Vulkanでは、OSに表示して欲しい画像をサーフェスというオブジェクトで管理します。
OSとの画面表示のやり取りはサーフェスを通して行い、描画が終わった画面を表示するように指示していきます。

今回のプログラムを入力して、[最終的に作られるコード](https://github.com/vulkanstudy/7_surface)はこちら。

## サーフェスのオブジェクト

### サーフェスの定義

サーフェスは、``VkSurfaceKHR``をハンドルとしてオブジェクト化されます。

```cpp:src/MyApplication.h 
class MyApplication
{
private:
  (中略)

  GLFWwindow* window_ = nullptr;
	VkInstance instance_;
	VkSurfaceKHR surface_;// ★追加

	VkPhysicalDevice physicalDevice_ = VK_NULL_HANDLE;
	VkDevice device_;
```

初期化は、物理デバイスを作成する前に行います。デバイスを生成する際に、サーフェスに対応しているのか調べながら選択することになるので、
インスタンスを作成した直後に初期化していきます。

片付けは、``vkDestroySurfaceKHR``を呼ぶだけでになります。対応する片付けメソッドに追加しましょう。

```cpp:src/MyApplication.h 
	// Vulkanの設定
	void initializeVulkan()
	{
		createInstance(&instance_);
		initializeDebugMessenger(instance_, debugMessenger_);
		surface_ = createSurface(instance_, window_);// ★追加
		physicalDevice_ = pickPhysicalDevice(instance_, surface_);// ★修正
		device_ = createLogicalDevice(physicalDevice_, graphicsQueue_, surface_);// ★修正
	}

	void finalizeVulkan()
	{
		vkDestroyDevice(device_, nullptr);
		finalizeDebugMessenger(instance_, debugMessenger_);
		vkDestroySurfaceKHR(instance_, surface_, nullptr);// ★追加
		vkDestroyInstance(instance_, nullptr);
	}
```

### サーフェスの生成

さて、実際に生成する``createSurface``の中身です。

サーフェスはOSに密接にかかわるので、Windowsでは、アプリケーションインスタンスやウインドウハンドルといったような、
ウィンドウに関する情報が必要になってきます。

具体的には、``VkWin32SurfaceCreateInfoKHR``構造体というのが定義されているので、こちらにWindows特有の情報を設定して、
``vkCreateWin32SurfaceKHR``関数を呼び出します。

```cpp:src/MyApplication.h 
	static VkSurfaceKHR createSurface(VkInstance instance, GLFWwindow* window)
	{
		VkSurfaceKHR surface;

		VkWin32SurfaceCreateInfoKHR createInfo = {};
		createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
		createInfo.hwnd = glfwGetWin32Window(window);
		createInfo.hinstance = GetModuleHandle(nullptr);

		if (vkCreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) {
			throw std::runtime_error("failed to create window surface!");
		}

		return surface;
	}
```

が、GLFWでは、OSの情報をGLFWwindowオブジェクトに隠ぺいして機種を問わず呼び出せるような仕組みが整っています。
ということで、実用上は、``glfwCreateWindowSurface``を呼び出すだけでサーフェスを作ることができます。

```cpp:src/MyApplication.h 
	static VkSurfaceKHR createSurface(VkInstance instance, GLFWwindow* window)
	{
		VkSurfaceKHR surface;
		if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
			throw std::runtime_error("failed to create window surface!");
		}

		return surface;
	}
```

# プレゼントキュー


論理デバイスの初期は、``VkDeviceCreateInfo ``構造体に情報をセットして、``vkCreateDevice``を呼び出します。
構造体の``sType``は、``VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO``です。

``VkDeviceCreateInfo ``構造体には、使用するキューファミリーを設定します。
キューファミリーは、``VkDeviceQueueCreateInfo``構造体に使用する情報を格納します。

![デバイスの初期化のイメージ](6/device_info.png "デバイスの初期化のイメージ")

コードとしては、長いですが、次のようになります。

```cpp:src/MyApplication.h 
	VkDevice createLogicalDevice(VkPhysicalDevice physicalDevice, VkQueue &graphicsQueue)
	{
		QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

		// 使用するキューに関する情報を記録
		VkDeviceQueueCreateInfo queueCreateInfo = {};
		queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
		queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();// キューファミリーのインデックス
		queueCreateInfo.queueCount = 1;// キューの個数

		float queuePriority = 1.0f;// キューの優先度を設定
		queueCreateInfo.pQueuePriorities = &queuePriority;

		// デバイスを生成するための情報を構築
		VkDeviceCreateInfo createInfo = {};
		createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;

		createInfo.pQueueCreateInfos = &queueCreateInfo;// VkDeviceQueueCreateInfo
		createInfo.queueCreateInfoCount = 1;

		VkPhysicalDeviceFeatures deviceFeatures = {};// 使用する機能の情報(今回は特に無し)
		createInfo.pEnabledFeatures = &deviceFeatures;

		createInfo.enabledExtensionCount = 0;// 拡張機能(今回は無し)

		// 論理デバイスの作成
		VkDevice device;
		if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
			throw std::runtime_error("failed to create logical device!");
		}
		
		return device;
	}
```

### 検証レイヤーの組み込み

なお、デバイスにも検証レイヤーを挟んでいきます。

```cpp:src/MyApplication.h 
class MyApplication
{
private:
	constexpr static char APP_NAME[] = "Vulkan Application";

	inline static std::vector<const char*> validationLayers = {// ★移動
		"VK_LAYER_KHRONOS_validation"
	};


	VkDevice createLogicalDevice(VkPhysicalDevice physicalDevice, VkQueue &graphicsQueue)
	{
		(中略)
		
		// ★追加：検証レイヤーの設定
		if (enableValidationLayers) {
			createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
			createInfo.ppEnabledLayerNames = validationLayers.data();
		}

		// 論理デバイスの作成
		VkDevice device;
		if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
			throw std::runtime_error("failed to create logical device!");
		}

		return device;
	}
```

ここで、検証レイヤー名の配列は、インスタンス生成とデバイスの生成の両方で使うので、メソッド内の変数から静的メンバーの置き換えました。

## デバイスキューの取得

実際に命令を出すキューは、論理デバイスに関連した、``VkQueue``としてオブジェクト化されます。
``VkQueue``は、デバイスが生成した直後に取得することにしましょう（インデックス情報のスコープがメソッド内だけのため）。

```cpp:src/MyApplication.h 
class MyApplication
{
private:
	constexpr static char APP_NAME[] = "Vulkan Application";

	inline static std::vector<const char*> validationLayers = {
		"VK_LAYER_KHRONOS_validation"
	};

	GLFWwindow* window_;
	VkInstance instance_;
	VkPhysicalDevice physicalDevice_ = VK_NULL_HANDLE;
	VkDevice device_;
	VkQueue graphicsQueue_; // ★追加
	VkDebugUtilsMessengerEXT debugMessenger_;// デバッグメッセージを伝えるオブジェクト

	VkDevice createLogicalDevice(VkPhysicalDevice physicalDevice, VkQueue &graphicsQueue)// ★引数の修正
	{
		(中略)
		
		// 論理デバイスの作成
		VkDevice device;
		if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
			throw std::runtime_error("failed to create logical device!");
		}

		// ★追加：キューの取得
		vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue);

		return device;
	}
```

このキューをどう使うかは、この後のお楽しみ

* [戻る](./)
